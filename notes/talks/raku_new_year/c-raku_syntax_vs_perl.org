* raku syntax vs perl
** raku continues to have a perlish feel, but--
*** object method calls via the more standard ".", not the "->"
**** the default object for "." is $_
**** string concationation is now "~" not "."
*** variable names typically have sigils still: $, @, %
**** the @ and % sigils now behave like part of the name, they're invariant:
***** Perl
#+BEGIN_SRC perl
my %fried;
$fried{eggs} = 2;
#+END_SRC 

***** Raku
#+BEGIN_SRC raku
my %fried;
%fried<eggs> = 2;
# alternately
%fried{'eggs'} = 2;
#+END_SRC 

**** you can also have names sans sigils (not done often)
#+BEGIN_SRC raku
my (\i, \j) = (2, 3);
say i + j:  ## 5
#+END_SRC

**** containers
***** typical vars are mutable, and have invisible "containers"
***** vars can contain immutables, bare constants without containers
#+BEGIN_SRC raku
my $var           = 3;

my $sorta_const  := 3;
$var++;           ## Works
$sorta_const++;   ## Error

my $alias  :=  $var;  
$alias++;  ## increments $var also
#+END_SRC
***** a 'scalar' can contain any object, including an aggregate (array, hash, etc)
****** similar to perl's references: $ doesn't mean "single"

*** flattening
**** in perl, nested lists flatten out unless you do something
**** in raku, nested structures are preserved, unless you do something

***** 
my @residual   = @list (-) @exceptions; ## weak: first element in array contains result

my @residual | = @list (-) @exceptions; ## better to "slip" out of container


*** everything is an object
**** chains of method calls are common
**** though there are function forms for many methods
**** smartmatch and given/when can work
***** helps to have a type system

*** scalar and list context have gone away in Raku
**** but many operators do implied type-conversion, which feels perlish

*** a push for consistency
**** e.g. {} almost always means a block of code 
*** one-pass parsing
**** unfortunate side effects e.g. this is no good: if( $this ) { ... }
